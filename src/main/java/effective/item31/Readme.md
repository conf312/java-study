## ITEM 31 - 한정적 와일드카드를 사용해 API 유연성을 높이자.

### 매개변수화 타입은 불공변이다. (아이템28)
List<String>은 List<Object>가 하는 일을 제대로 수행하지 못하니 하위 타입이 될 수 없다. (리스코프 치환 원칙 위배)
`Main.java -> 9번 라인`

- 유연성을 극대화 하려면 원소의 생산자나 소비자용 입력 매개변수에 와일드카드 타입을 사용하라.
- 자바는 이런 상황에 대처할 수 있는 한정적 와일드카드 타입이라는 특별한 매개변수화 타입을 지원한다.
```java
? extends E // 생산자
? super E // 소비자
```

### 단, 입력 매개변수가 생산자와 소비자 역할을 동시에 한다면 와일드카드 타입을 써도 좋을게 없다. (타입을 정확히 지정해야하는 상황이기 때문에)

###  ❗️ 어떤 와일드카드 타입 사용해야 하는지 기억하는데 도움이 되는 공식
#### 펙스(PECS): producer-extends, consumer-super
매개변수화 타입 T가 `생산자라면 <? extends T>`를 사용하고 `소비자라면 <? super T>`를 사용하라.
- PECS 공식은 와일드카드 타입을 사용하는 기본 원칙이다. 
- 나프탈린과 와들러는 이를 겟풋 원칙으로 부른다.

### 메서드 선언에 타입 매개변수가 한 번만 나오면 와일드카드로 대체하라.
- 아래에서 2번째 와일드카드 타입을 사용해야 하는 이유 - public API 라면 명시한 인덱스의 원소를 교환해주며, 신경 써야 할 타입 매개변수도 없어진다.

```java
public static <E> void swap(List<E> list, int i, int j);
public static void swap(List<?> list, int i, int j);
```

### 반환 타입에는 한정적 와일드카드 타입을 사용하면 안된다.
클라이언트 코드에서도 와일드카드 타입을 써야하기 때문이다.

### 정리
- 와일드카드 타입을 적용하면 API가 훨씬 유연해진다.
- 널리 쓰일 라이브러리를 작성한다면 반드시 와일드카드 타입을 적절히 사용해줘야 한다.
- PECS 공식을 기억하자. 생산자는 `extends`  소비자는 `super`
- comparable 과 Comparator 는 모두 소비자라는 사실을 잊지 말자.
