## ITEM 79 - 과도한 동기화는 피하라.
아이템 78에서는 충분하지 못한 동기화의 피해를 다뤘다면, 이번 아이템에서는 반대 상황을 다룬다.

### ❗️ 응답 불가와 안전 실패를 피하려면 동기화 메서드나 동기화 블록 안에서는 제어를 절대로 클라이언트에 양도하면 안된다.
1. 동기화된 영역 안에서는 재정의 할 수 있는 `메서드`는 호출하면 안된다.
2. 클라이언트가 넘겨준 `함수 객체(아이템24)` 를 호출하면 안된다.
3. 동기화된 클래스 관점에서 이런 메서드는 모두 바깥 세상에서 온 외계인이다.
4. 외계인 메서드가 하는 일에 따라 동기화된 영역은 예외를 일으키거나, 교착상태, 데이터 훼손할 수도 있다.

### <코드 79-1> 잘못된 코드, 동기화 블록안에서 외계인 메서드를 호출한 예시
- item79 -> Main.java
- observer의 added는 동기화된 영역에서 재정의할 수 있는 메서드로 클라이언트에게 제어권이 있다. 
- 클라이언트는 관찰자를 추가할 때 람다식이나 익명 클래스를 사용하여 added 메서드를 재정의했다. 
- 동기화된 영역에서 사용되는 added 메서드를 동기화 영역 밖에서 재정의한 것이다.

#### `notifyElementAdded` 메서드에서 수행하는 순회는 동기화 블록 안에 있으므로 동시 수정이 일어나지 않도록 보장하지만, 정작 setObserver 자신이 콜백을 거쳐 되돌아와 수정하는 것까지 막지는 못한다.

### ConcurrentModification 
동기화된 컬렉션에 대해서 `반복`문을 실행하는 도중에 컬렉션 클래스 내부의 값이 `변경`되는 상황이 포착되면 그 즉시 `ConcurrentModificationException` 이 발생하고 즉시 멈춤 `fail fast` 를 하는 것을 말한다.

