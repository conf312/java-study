## ITEM 26 - 로 타입은 사용하지 말라. (타입 매개변수가 없는 제네릭 타입)

### 제네릭이 생기기 이전
- 컬렉션에서 객체를 꺼낼 때마다 형변환을 해야 했다.
- 다른 타입 객체를 넣어두면 런타임 형변환 오류가 빈번하게 발생했다.

### 제네릭(Generic) 
- 자바 5부터 사용할 수 있다
- 컬렉션이 담을 수 있는 타입을 컴파일러에 알려줌으로써 컴파일러는 형번환 코드를 추가할 수 있게 되고, 엉뚱한 타입의 객체를 넣으려는 시도를 컴파일 과정에서 차단한다.

### 제네릭 클래스, 제네릭 인터페이스
클래스와 인터페이스 선언에 타입 매개변수(type parameter)가 존재한다.
```java
public class Person<E>
public interface Collection<E>
```

### 컬렉션의 로 타입 - 따라하지 말 것
```java
// stamp 인스턴스만 취급한다.
private final Collections stamps = ...;

// 실수로 동전을 넣는다.
stamps.add(new Coin(...)); // unchecked call 경고를 내뱉는다.
```
해당 코드를 사용하면 실수로 stamp 대신 coin을 넣어도 아무 오류 없이 컴파일되고 실행된다.

### 컬렉션에서 이 동전을 다시 꺼내기전에는 오류를 알아채지 못한다.
```java
for (Iterator i = stamps.iterator(); i.hashNext();) {
    Stamp stamp = (Stamp) i.next(); // ClassCastException 발생
    stamp.cancel();
}
```
사용하려는 시점에서 오류가 발생하면 문제를 겪는 코드와 원인을 제공한 코드가 물리적으로 떨어져 있을 가능성이 커진다.
해당 문제의 지점을 찾기 위해 전체를 훑어봐야 할 수도 있다.

### 매개변수된 컬렉션 타입 - 타입 안전성 확보
컴파일 시점에 문제의 원인을 바로 알 수 있다.
```java
private final Collection<Stamp> stamps = ...;

// 이제 stamps에 엉뚱한 타입의 인스턴스를 넣으려 하면 컴파일 오류가 발생하며 무엇이 잘못 됐는지를 정확히 알려준다.
// incompatible types: Coin cannot be converted
stamps.add(new Coint());
```

### 로 타입을 쓰면 제네릭이 안겨주는 안정성과 표현력을 모두 잃게 된다.
그렇다면 쓰지 말아야하는 타입을 애초에 왜 만들어놓은 걸까?      
- 호환성 때문이라고 한다. 제네릭을 받아들이기까지 거의 10년이 걸린 탓에 제네릭 없이 짠 코드가 이미 세상을 뒤덮어 버렸다.
- 그래서 기존 코드를 수용하면서 제네릭을 사용하는 코드와 맞물러 돌아가게 해야했다.

### 비한정적 와일드카드 타입을 사용하라. - 타입 안전하며 유리하다.
- null 외에는 어떤 원소로 넣을 수 없다.
- 다른 원소를 넣으려하면 컴파일 에러를 보게 될 것이다.
- 즉, 타입 불변식을 훼손하지 못하게 막았다.
```java
List<?>
```

### 한정적 와일드카드 타입
```java
List<? extends Number>
```

### 정리
- 로 타입을 사용하면 런타임 예외가 일어날 수 있으니 사용하면 안된다.
- 로 타입은 제네릭이 도입 되기전 이전 코드와의 호환성을 위해 제공될 뿐이다.




