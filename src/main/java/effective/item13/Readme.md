## ITEM 13 - clone 재정의는 주의해서 진행하라.
### clone 메서드
모든 필드를 복사하여 새로운 객체에 넣어 반환하는 동작을 수행한다. 즉, 필드의 값이 같은 객체를 새로 만드는 것이다.

clode 메서드가 선언된 곳은 Cloneable이 아니라 Object이다.
그래서 바로 @Override 해서 사용하려고 하면 CloneNotSupportedException 에러가 난다.

그렇다면 어떻게 사용 해야 하나?
Cloneable을 구현할 클래스에서 Object의 protected 메서드인 clone 동작 방식을 결정한다.

객체를 복제하는 경우 원본 객체와 복제된 객체가 같은 객체를 공유하므로 둘 중 하나만 변경되어도 두 객체가 모두 바뀐다. 이는 완전한 복제라고 볼 수는 없으며 이런 복제를 얕은 복사(shallow copy) 라고 한다.₩

### 복사 생성자와 복사 팩터리
☑️ 복사 생성자(변환 생성자)
- 자신과 같은 클래스의 인스턴스를 인수로 받는 생성자

[복사 생성자]
```java
public Yum(Yum yum){
...
}
```

☑️ 복사 팩터리(변환 팩터리)
- 복사 생성자를 정적 팩터리 형식으로 정의

[복사 팩터리]
```java
public static Yum newInstance(Yum yum){
...
}
```
복사 생성자와 복사 팩터리는 Cloneable/clone 방식처럼 정상적인 final 필드 용법과 충돌하지 않으며, 불필요한 검사예외(Exception) 처리를 하지 않아도 되고 형변환도 필요하지 않으며 객체 생성 메커니즘(생성자를 쓰지 않는 방식)을 사용하지도 않는다.
해당 클래스가 구현한 인터페이스 타입의 인스턴스를 인수로 받을 수 있어 이들을 이용하면 복제본 타입을 선택하는데 있어 유연성이 향상될 수 있다

### 정리
- 인터페이스를 만들 때는 절대 Cloneable을 확장해선 안된다.
- Cloneable은 클래스의 믹스인(사용) 의도로 만들어진 것이다.
- final 클래스라면 Cloneable을 구현해도 위험은 크지 않지만, 성능 최적화 관점에서 검토 후에 드물게 허용해야 한다.
- 복제 기능은 생성자와 팩터리를 이용하는 것이 최고이다.
- 단, 한가지 예외는 배열을 복사할 때이다.