## ITEM 13 - clone 재정의는 주의해서 진행하라.
### clone 메서드
모든 필드를 복사하여 새로운 객체에 넣어 반환하는 동작을 수행한다. 즉, 필드의 값이 같은 객체를 새로 만드는 것이다.

clode 메서드가 선언된 곳은 Cloneable이 아니라 `Object`이다.
그래서 바로 @Override 해서 사용하려고 하면 `CloneNotSupportedException` 이 발생한다.

### 그렇다면 어떻게 사용 해야 하나?
Cloneable을 구현할 클래스에서 Object의 protected 메서드인 clone 동작 방식을 결정한다.

일반적인 인터페이스의 동작방식과 다르게 상위 Object 클래스에 protected 접근자로 된 clone() 메서드가 존재하고, 그걸 오버라이드 해야 한다.

### 왜? Object.clone()은 protected 인가?
1. 객체의 복제를 안전하게 제어하고, 불필요한 복사를 방지하기 위함
2. 접근 제어자는 클래스 내부와 같은 패키지 내의 클래스에서는 접근 가능하지만, 외부 패키지의 클래스에서는 직접 접근할 수 없도록 제한
3. public으로 제공하게 되면 객체의 복제를 무제한으로 허용하는 것이 될 수 있습니다. 이 방법은 객체의 내부 상태를 제어하고, 부작용을 예방하기 어려워지는 문제를 일으킬 수 있습니다.

```
따라서, 객체를 복제하려는 클래스에서는 이 메서드를 오버라이딩하여 public 접근 제어자로 바꾸어 사용해야 합니다.  
이렇게 함으로써 복제의 책임과 제어를 개발자에게 맡김으로써 안전하게 객체의 복제를 처리할 수 있습니다.           
```

### 믹스인
- 클래스가 다른 클래스의 기능을 "혼합"하여 사용할 수 있는 기법을 말합니다.
- 믹스인은 다중 상속의 한계를 극복하기 위해 도입된 개념으로, Java에서는 다중 상속을 지원하지 않기 때문에 여러 클래스로부터 기능을 상속받는 것이 불가능합니다.
- 믹스인은 이러한 제약을 극복하면서도 클래스 간의 코드 재사용을 높일 수 있는 방법입니다.

### 가변 객체 clone
가변 객체를 복제하는 경우 원본 객체와 복제된 객체가 같은 객체를 참조하므로 둘 중 하나만 변경되어도 두 객체가 모두 바뀐다. 
이는 완전한 복제라고 볼 수는 없으며 이런 복제를 `얕은 복사(shallow copy)` 라고 한다.

### 얕은 복사의 특징:
- 원본 객체와 복사본 `객체가 같은 내용을 참조`합니다.
- 객체의 크기가 크거나 복잡한 구조를 가진 경우, `복사 비용이 낮아집니다.`
- 하지만 객체의 내용이 변경되면 복사본과 원본 모두에 영향을 미칩니다.

### 깊은 복사 (Deep Copy)
깊은 복사는 객체를 복사할 때, 원본 객체의 내용을 완전히 `새로운 객체`로 복사하는 방식입니다. 
즉, 객체 내부의 모든 필드 및 하위 객체들까지 복사됩니다. 
이를 통해 원본 객체와 복사본 객체는 `완전히 독립적인 별개의 객체`가 됩니다.

### 깊은 복사의 특징
- 원본 객체와 복사본 객체가 서로 독립적으로 존재하며, 하나의 `객체의 변경이 다른 객체에 영향을 주지 않습니다.`
- 객체의 구조가 복잡하고 `객체 간의 의존성이 높을 때 유용`합니다.
- 객체의 크기나 구조에 따라 `복사 비용이 높을 수 있습니다.`

## 복사 생성자와 복사 팩터리
☑️ 복사 생성자(변환 생성자)
- 자신과 같은 클래스의 인스턴스를 인수로 받는 생성자

```java
public Yum(Yum yum) {
...
}
```

☑️ 복사 팩터리(변환 팩터리)
- 복사 생성자를 정적 팩터리 형식으로 정의
```java
public static Yum newInstance(Yum yum) {
...
}
```
- 복사 생성자와 복사 팩터리는 Cloneable/clone 방식처럼 정상적인 final 필드 용법과 충돌하지 않으며, 불필요한 검사예외(Exception) 처리를 하지 않아도 되고 형변환도 필요하지 않으며 객체 생성 메커니즘(생성자를 쓰지 않는 방식)을 사용하지도 않는다.
- 해당 클래스가 구현한 인터페이스 타입의 인스턴스를 인수로 받을 수 있어 이들을 이용하면 복제본 타입을 선택하는데 있어 유연성이 향상될 수 있다.

### 정리
- 인터페이스를 만들 때는 Cloneable을 확장해선 안된다.
- Cloneable은 클래스의 믹스인(사용) 의도로 만들어진 것이다.
- final 클래스라면 Cloneable을 구현해도 위험은 크지 않지만, 성능 최적화 관점에서 검토 후에 드물게 허용해야 한다.
- 복제 기능은 생성자와 팩터리를 이용하는 것이 최고이다.
- 단, 한가지 예외는 배열을 복사할 때이다.
